coderfun
码农翻身笔记

### 3 浪潮之巅的Web
超文本标记语言HTML -> 浏览器（Chrome, IE）展示-> 网络服务器（Appache, Ngnix）解析

#### Socket服务
端口可能被防火墙屏蔽，但是不会屏蔽Web服务的端口
Web服务：HTTP-80  HTTPS-443  GET/POST + JSON

#### 对称加密
双方持有相同的公共的密钥
#### 非对称加密-RSA
用私钥加密的数据只有对应的公钥才能解密，用公钥加密的数据只有对应的私钥才能解密。A端先用B端的公钥加密要发送的消息，B端收到消息后用自己的私钥解密
以非对称加密的方式将对称加密的密钥传输后再用对称加密算法进行通信
#### 中间人劫持
B端发送自己公钥的时候被中间人劫持后将自己的公钥发送到A端，A端用中间人的公钥发送消息，中间人用自己的私钥解密后，用A的公钥发送消息到B端，B端用自己的私钥解密后返回的消息被中间人用自己的私钥解密

#### 数字签名
B端把自己的公钥和个人信息用一种Hash算法（MD5, SHA，具有不可逆性，抗冲突性和分布均匀性）生成一个消息摘要，只要输入数据有一点变化，生成的消息摘要会发生巨变。让认证中心CA用它的私钥对消息摘要加密，形成签名

#### 数字证书
把原始信息和数字签名合并。当A端收到B端的证书时，就用同样的Hash算法再次生成消息摘要，然后用CA的公钥对数字签名解密，得到CA创建的消息摘要，两者对比就知道有没有被篡改。CA的公钥如何防止被中间人劫持？CA本身也有证书来证明自己的身份，由CA得上一级来验证，再由上一级验证。。。链条的根部就是操作系统/浏览器预制的顶层CA证书

#### HTTPS流程
1. 浏览器发出安全请求访问某个网址
2. 服务器发送数字证书（包含服务器的公钥）
3. 浏览器用预制的CA列表验证证书，如果有问题则提示风险
4. 浏览器生成随机的对称密钥，用服务器的公钥加密
5. 服务器用自己的私钥解密，得到对称密钥
6. 双方都知道了对称密钥，用它来加密通信

#### 登录流程
1. 输入用户名和密码
2. 验证通过就建立session
3. 把sessionID通过cookie 发送给浏览器
4. 下次访问URL的时候，cookie就会发过来，判断是否已经登录了

#### 单点登录
cookie是无法跨域的，即a.com产生的cookie浏览器不会发送到b.com，如果多个系统的架构不同，语言不同，共享session很麻烦
COBOL-慢
用户在某个系统登录后，在cookie中生成一个token，访问别的系统时验证下token，如果没问题，就认为用户已经登录，每个系统生成token的时候，需对有header信息和userID的数据用Hash算法和密钥生成一个签名，签名本身和header信息和userID组成完整的token，收到token后，用同样的算法对header信息和userID进行计算签名，如果双方签名一致，则取出userID使用，但是各个系统的userID可能不一样

#### CAS
Central Authentication
1. 如果网址A需要登录，先重定向到认证中心
2. 如果没登录，则让用户登录，成功后
3. 认证中心会创建一个session，一个ticket（随机字符串），注册系统A
4. 认证通过后，再重定向到网址 www.a.com/A， 此时URL中带着ticket，cookie也会发到浏览器
5. 浏览器拿着ticket去认证中心确认，用户是否已经登录
6. 如果登录过了，网站服务器就创建session，返回A这个资源给浏览器，自己的cookie也发给浏览器
7. 如果再次访问同一域名下的 www.a.com/B， 浏览器会携带网站服务器的cookie判断已经登录过了，就不会再登录
8. 如果要访问不同域名下的 www.b.com/A， 浏览器将之前保存的认证中心的cookie发给认证中心
9. 验证已经登录后，再重定向到网址A，并返回另一个ticket
10. 浏览器拿着ticket去认证中心确认，验证ticket有效后，注册系统B
11. 如果登录成功，网站服务器就创建session，返回A这个资源给浏览器，自己的cookie也发给浏览器
12. 如果再次访问同一域名下的 www.b.com/B， 浏览器会携带网站服务器的cookie判断已经登录过了，就不会再登录

##### Oauth-token（资源所有者密码凭据许可-Resource Owner Password Credentials Grant）
从邮箱自动读取与信用卡有关的信息进行分析汇总后形成报表，但是需要邮箱用户名和密码
重定向到网易认证系统，用用户名和密码登录后，系统会询问是否允许“信用卡”管家访问邮箱，确认后，再重定向到管家网址，同时带token（认证系统授权）过来，用token就可以通过API访问邮箱，在这个过程中不会接触到用户名和密码
##### Oauth-Hash Fragment（隐式许可-Implicit Grant）
只会停留在浏览器端，只有JavaScrip才能访问，不会再次通过HTTP Request发送到别的服务器，token是明文的，虽然以HTTPS传输，但在浏览器的历史记录和访问日志能找到
##### Oauth-授权码（授权码许可-Authorization Code Grant）
通过认证系统的授权后，不直接发token，而是发送授权码，管家拿着授权码再次访问认证系统，该授权码和管家的app_id和app_code关联，验证成功后才发送token给管家，浏览器不直接接触token
```
资源所有者：用户  资源服务器：邮箱  客户端：信用卡管家  授权服务器：认证系统
```

#### 数据库缓存
建立数据库连接的代价极为昂贵
```
计算机行业的所有问题都可以通过增加一个抽象层来解决
```
把数据库数据以java对象的形式缓存在内存，在进行数据库操作时先在缓存中查询，如果没有再去调用数据库连接；如果把缓存和应用程序都放在应用服务器Tomcat，则在同一进程中，可以直接访问，效率最高；然而当用户量大的时候处理起来会力不存心，缓存需要存放到单独的服务器中去，此时需要将java对象序列化保存传输，效率会降低
#### Redis
可以快速的存储海量key-value字符串，如一个User对象有三个属性，id, name, email，可以生产两个key-value来存储（"name_id", "sky"）和（"email_id", "sky@gamil.com"），可以先序列化再以二进制方式存储，不过以JSON格式存储更为普遍，可以支持List（可当做队列或栈）, Set（无序集合，包含不重复的字符串），Sorted Set（有序集合）， Hash（键值对的无序散列表）
#### Jedis
Tomcat的客户端，Tomcat把数据转换为JSON后，其余工作由Jedis处理，无需关心跨网络访问细节，当数据越来越多时，Redis也需要部署多台
##### 余数算法
对于需要存储的key-value，计算出key的Hash，对服务器数目取余数，方便快速，然而如果要增加一台服务器，则难以处理
##### 一致性Hash算法
对于0-2的32次方的数据画一个圆，范围每个Redis服务器等分，每个服务器的IP或hostname取Hash值，对于数据key-value，key取个Hash值，按顺时针，key的Hash值接近哪个服务器，则存储到哪个如武器；如果增加一台服务器，则会使这台服务器和逆时针相邻的那台服务器之间的缓存数据失效
##### Hash槽
每台服务器平均分管16384个槽，对数据key-valu，先对key运用CRC16算法产生一个整数值，再进行Hash值后对16384取余，属于哪个槽就将数据存储到哪个服务器；如果增加一台服务器，则把其他服务器的一些数据key-value都迁移到新的服务器
#### Redis Cluster
负责统筹协调各个Resi服务器之间的通信
#### 故障转移
如果是集群，需要支持故障转移，卡槽分为两组服务器，特别提供了master-slave功能，如nodeMster-A, nodeSlave-A1, nodeSlave-A2和nodeMaster-B, nodeSlave-B1, nodeSlave-B2，master和slave的数据是一样的，如果master挂掉，马上用备份slave替换为master
#### Nginx
处理简单的静态资源，HTTP请求, HTML, JS, CSS ，虽然稳定强大，却只有一个实例，增加一个服务器，让keepalive把他们形成master-slave结构，对外只提供一个IP地址，一个服务器挂了，另一个马上接管，只转发请求，不保存状态，但要保证Tomcat的负载均衡
#### Tomcat
处理动态资源请求，有Session
##### 失效转移
在Tomcat1上创建的购物车，服务器挂了，则购物车，登录信息这些状态将不复存在，将这些Session都缓存到Redis的集群
#### 数据库的读写分离
Web应用的读操作远远多于写操作，可以把一个master服务器设置为可读可写，其他的slave服务器只读，读写分离还可以极大的缓解程序对X（排它锁）锁和S（共享锁）锁的争用，如果master挂了，slave马上成为master；可以增加一个代理层，来负责各个服务器之间的协调，控制把Tomcat的写操作发到master，读操作发到slave
#### 本地过程调用
所有的函数调用都在同一个进程
#### 远程过程调用RPC
客户端的代理Stub和服务器端的代理Skeleton，通过socket或者http通信，把复杂的网络细节隐藏，在客户端看来和本地过程调用一样，但是要慢很多，不管传递的是基本数据类型还是对象都要进行序列化
#### SOA
Service-Oriented Architecture, SOA解决多服务凌乱问题，SOA架构解决数据服务的复杂程度，同时SOA又有一个名字，叫做服务治理, SOA的提出是在企业计算领域，就是要将紧耦合的系统，划分为面向业务的，粗粒度，松耦合，无状态的服务。服务发布出来供其他服务调用，一组互相依赖的服务就构成了SOA架构下的系统
#### 微服务
各个小组件之间最好通过最轻量级的基于HTTP的RESTful对外提供接口，WSDL、SOAP太重了,
微服务与SOA相比，更强调分布式系统的特性，比如横向伸缩性，服务发现，负载均衡，故障转移，高可用。互联网开发对服务治理提出了更多的要求，比如多版本，比如灰度升级，比如服务降级，比如分布式跟踪，这些都是在SOA实践中重视不够的
#### Docker
自动化快速部署，将代码和环境一起形成镜像，把其放在服务器端的docker运行环境中，开发环境，测试环境，生产环境轻松保持一致; Docker容器技术的出现，为微服务提供了更便利的条件，比如更小的部署单元，每个服务可以通过类似Node.js或Spring Boot的技术跑在自己的进程中。可能在几十台计算机中运行成千上万个Docker容器，每个容器都运行着服务的一个实例。随时可以增加某个服务的实例数，或者某个实例崩溃后，在其他的计算机上再创建该服务的新的实例
#### 框架
框架是一个半成品，无法独立运行，必须有开发人员去定义他的规则，把项目的代码放到指定的地方，由框架整合起来，才是一个完整的程序;单纯的通过
Java Web基础：HTTP, HTML, JavaScript, CSS, Servlet, JSP, Tomcat...去做整合，非常复杂，Spring MVC，Hibernate，MyBatis都是流行框架，但是框架只实现了很小一部分业务，还有系统架构设计、缓存、性能、高可用性、安全、备份等等
#### HTTP Server
浏览器向服务器发送HTTP Request，服务器收到后让操作系统建立HTTP层下面的TCP连接通道socket，并提供socket，bind，listen，accept等接口，如果是单进程，就会阻塞，主要是receive会很慢，获取到数据后再send出去；可以让主进程监听80端口，但只负责接收连接请求，具体事务receive和send通过创建子进程处理，但是如果并发的连接请求任务特别多，每个进程要耗费大量的系统资源，切换进程就非常耗时，把子进程改成线程，也无法根本解决问题
#### select模型
一个socket连接是一个所谓的文件描述符fd_set的简单的数据结构，如果用重量级的进程对其读写太浪费，HTTP Server发送需要检查socket有没有数据的请求给操作系统，然后阻塞，操作系统会在后台检查这些编号的socket，如果发现可以读写，则做一个标记，再唤醒HTTP Server，去处理这些socket数据，处理完毕之后，把那些socket fd通知操作系统，再进入阻塞；只是HTTP Server 需要把 fd_set 不断的复制给操作系统，很耗资源，从阻塞中唤醒后需要遍历1024个socket，看看有没有标志位需要处理，实际上很多socket并不活跃，需要处理的并不多
#### epoll模型
1. 操作系统维护一个需要监控的socket集合
2. HTTP Server告知操作系统哪些socket需要处理，然后阻塞
3. 操作系统返回需要处理的fd_set给HTTP Server
4. HTTP Server仅仅处理操作系统发回来的socket
